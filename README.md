# CPP_BiTree
### Продолжение работы с классами, коллекциями(см. предыдущее задание с журналом(CPP_StepIntoOOP))
### Условие задачи:
Бакалавров с факультета математики, ухаживающих за бинарным деревом, не устраивает существующий журнал, поскольку они хотят знать заранее, кому в какой день приходить. Для этого им нужна программа, позволяющая вводить соответствия K и V, а также составляющая список V в порядке возрастания K.

### Коллекция:
Бинарное дерево <K, V> с методом, возвращающим список значений V в порядке возрастания ключа K
K = дата; V = студент (строка)

### Структура класса:
- класс является шаблонным и соответствует своему варианту
- коллекция реализована на основе бинарного дерева по аналогии с std::map или QMap
- считать, что для типа K реализован оператор >
- класс содержит перечисленные пункты
    - конструктор по умолчанию и конструктор копирования
    - деструктор
    - метод, удаляющий все хранящиеся значения из коллекции
    - метод, возвращающий количество хранящихся в коллекции значений
    - метод, принимающий путь к файлу и сохраняющий в него содержимое коллекции
    - метод, принимающий путь к файлу и загружающий из него содержимое коллекции
    - оператор ==, принимающий другую коллекцию и возвращающий истину, если обе коллекции хранят одинаковые значения T (или пары ключ-значение K, V) и ложь в противном случае
    - метод, добавляющий в коллекцию заданную пару ключ-значение K, V 
    - метод, удаляющий из коллекции пару ключ-значение по произвольному ключу K
    - оператор [], принимающий ключ K и возвращающий его значение V по ссылке
    - метод, принимающий ключ K и возвращающий при его наличии в коллекции истину, а при отсутствии – ложь
    - метод, возвращающий список всех значений V в порядке возрастания ключа K
- класс устойчив к ошибкам:
    - в деструкторе коллекции освобождается вся выделенная ей память
    - публичные методы коллекции не принимают и не возвращают указатели на свои поля

### Тестирование:
##### Тесты отвечают следующим требованиям:
- все тесты вызываются из функции main() (не в коде созданных классов)
- для тестирования используется функция assert() из библиотеки assert.h
- исключить дублирование данных при проверке
- при отсутствии ошибок выводится сообщение об успешном прохождении тестов

##### Перечисленные функции успешно проходят тестирование:
- размер коллекции, созданной конструктором по умолчанию, равен нулю
- непустая коллекция после удаления всех объектов равна коллекции, созданной при помощи конструктора по умолчанию)
- непустая коллекция, сохранённая в файл, равна новой коллекции, загруженной из того же файла
- при добавлении новой пары ключ-значение K, V размер коллекции увеличивается на единицу, а при добавлении имеющейся пары ключ-значение K, V размер не изменяется
- метод, проверяющий наличие ключа принимает добавленный ключ K и возвращает истину
- оператор [] принимает добавленный ключ K и возвращает его значение V
- при удалении существующего ключа K размер коллекции уменьшается на единицу, а при удалении отсутствующего ключа K размер не изменяется
- метод, принимающий ключ K и возвращающий при его наличии в коллекции истину, а при отсутствии - ложь
- копия непустой коллекции равна оригиналу, после изменения одного из значений V равенство нарушается

### Графический интерфейс:
- присутствуют все элементы интерфейса для работы с коллекцией:
    - есть возможность добавлять и удалять элементы коллекции, а также сохранять коллекцию в указанный пользователем файл и загружать коллекцию из указанного пользователем файла
    - присутствуют элементы интерфейса, необходимые для проверки выполнения задания (в зависимости от варианта)
- есть элемент интерфейса, отображающий всё содержимое коллекции:
    - для вывода коллекции используется QListWidget, QTableWidget или QTreeWidget

### Эффективность интерфейса:
- элементы интерфейса адаптируются к ситуации:
    - элемент интерфейса, выводящий содержимое коллекции, автоматически обновляется при её изменении
    - пользователь получает обратную связь (напр. всплывающая подсказка, диалоговое окно) при совершении ошибки
    - интерактивные элементы интерфейса выключаются или скрываются в моменты, когда нет возможности или смысла с ними взаимодействовать
